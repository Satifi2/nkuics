## 1 概述

### 1.1 实验目的

### 1.2 实验内容

#### 1.2.1实验环境

- **虚拟机**：VMware17 PRO，本来从百度网盘下载的镜像是VM15 PRO，但是vm-tools安装不上【难点】，主机和虚拟机之间无法复制，所以改用了VMware17 PRO（密钥是网上公开的），助教说系统一致可以保证实验环境一致，而虚拟机不影响。

- **系统**：百度网盘里的Ubuntu系统，担心影响实验环境，没有升级。

- **vm-tools和共享文件夹**：
  下载vm-tools：

  ```shell
  sudo apt install open-vm-tools
  sudo apt install open-vm-tools-desktop
  ```

  设置好共享文件夹的位置，去/mnt/hgfs当中访问即可

- **开发工具**：VScode，由于共享文件夹，可以用Windows中的vscode修改文件，在Ubuntu当中生效，所以特别方便。
  ![image-20240306233116401](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240306233116401.png)

- **前置安装工作：**

  ```shell
  sudo apt-get install build-essential
  sudo apt-get install gdb
  sudo apt-get install git
  sudo apt install vim
  sudo apt-get install libreadline-dev
  sudo apt-get install libsdl2-dev
  sudo apt-get install qemu-system-x86
  ```

- **下载项目：** 

  ```shell
  git clone -b 2017 https://github.com/NJU-ProjectN/ics-pa.git ics2017
  ```

- **配置git信息:**
  用户名是我的学号和名字，邮箱是学生邮箱。

  ```shell
  git config user.name "2112847DuYixing"
  git config user.email "2112847@mail.nankai.edu.cn"
  git branch -m master
  ```

- **初始化：**
  这里我还了解到，bash init.sh还会涉及一些系统文件的设置，也就是说必须执行初始化之后的文件不能随便移动。
  
  ```bash
  bash init.sh
  ```
  
  ![image-20240306233235391](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240306233235391.png)

中间我还遇到了init.sh连接GitHub被拒绝的问题【难点】

```shell
fatal: unable to access 'https://github.com/NJU-ProjectN/nanos-lite.git/': Failed to connect to github.com port 443: Connection refused
```

解决方法是去csdn发现了下面的方法：

```shell
git config --global --unset http.proxy
git config --global --unset https.proxy
git config --global http.sslVerify "false"
```

- **查看gitlog**

  ```shell
  git log
  ```

  ![image-20240307001817261](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240307001817261.png)

  可以看到我在2024年3月6日等多日的记录。

  这里还遇到无法退出git log,CTRL+C也不行，后面发现应该是vim的退出方式，也就是:wq【插曲】。

- 尝试运行make run的时候还提示要去subproject里面，原来是要在nemu文件夹当中执行【插曲】

- 在nemu文件夹不可以执行git操作，因为需要在有.git的根目录【插曲】

- 创建新分支并切换到新分支

  ```shell
  git checkout -b pa1
  ```

  将新分支推送到远程仓库

  ```shell
  git push -u origin pa1
  ```

  















## 2 阶段一

### 2.1 简单计算机模型

#### 2.1.0 Makefile干了什么

要搞清楚make run干了什么，我先去看来make file。
![image-20240309231411656](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240309231411656.png)

​	**前五行定义了编译时的文件位置**。变量 `NAME` 的值为 `nemu`，然后 将当前目录下的 `include` 目录添加到变量 `INC_DIR` 中，然后如果变量 `BUILD_DIR` 未被之前定义，那么将其设置为当前目录下的 `build` 目录，类似地，设置 `OBJ_DIR` 为 `BUILD_DIR` 下的 `obj` 子目录。**`BINARY` 变量，代表最终生成的二进制文件的位置，也就是nemu。**

1. `include Makefile.git`: 包含另一个名为 `Makefile.git` 的 Makefile 文件。
2. `.DEFAULT_GOAL = app`: 设置默认目标为 `app``
3. ``CC = gcc`: 设置 C 编译器为 gcc。
4. `LD = gcc`: 设置链接器为 gcc。
5. `INCLUDES = $(addprefix -I, $(INC_DIR))`: 生成编译时包含的目录参数。
6. `CFLAGS += -O2 -MMD -Wall -Werror -ggdb $(INCLUDES)`: 设置 C 编译器标志

其中`Makefile.git`很有意思，`--author='tracer-ics2017 <tracer@njuics.org>'`: 设置提交的作者。

这就是为什么我可以在`git push -u origin `到GitHub（放心，是私有的）的时候看到我自己和另外一个作者的原因。

另外输出一些信息（包括传递给函数的消息、学生ID、用户名、系统信息、系统运行时间和一些随机数据），然后使用这些信息作为提交信息。
![image-20240309233248546](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240309233248546.png)

根据实验手册，需要修改这里的`STU_ID=2112847`。

我一直很好奇，为什么我一执行make run就会有一次commit，而且commit当中同时有run和commit，原来是因为：

在这个 `run` 目标中，发生了以下几个步骤：

1. `$(BINARY)`: 这是 `run` 目标的依赖项。它确保在运行 `run` 目标之前，必须先构建好 `$(BINARY)`（即程序的可执行文件）。在 `$(BINARY)` 目标中调用了 `git_commit` 函数并传递了 "compile" 作为参数,**所以同时会有run和commit。**
2. `$(call git_commit, "run")`: 这是 Makefile 中的函数调用语法。这里，它调用了 `Makefile.git` 中定义的 `git_commit` 函数，并传递了字符串 `"run"` 作为参数。这意味着**每次执行 `make run` 命令时，`git_commit` 函数都会被触发**，它会向 Git 仓库添加一个新的提交，提交信息中会包含 `"run"` 字符串以及其他在 `Makefile.git` 中定义的信息。
3. `$(NEMU_EXEC)`: 最后，执行由 `NEMU_EXEC` 变量定义的命令，即运行构建的程序。

![image-20240309233606273](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240309233606273.png)

我很好奇，如果单独执行 `make`，会执行什么。实验发现：

在 Makefile 中，`.DEFAULT_GOAL` 被设置为 `app`。所以，如果如果只运行 `make` 而不带任何参数，它将执行 `app` 目标：

```
.DEFAULT_GOAL = app
app: $(BINARY)
```

这会导致构建 `$(BINARY)`，如果 `$(BINARY)` 依赖的源代码文件有变化的话，它会重新编译。也就是我发现之前make过，之后在make只会输出`make: Nothing to be done for 'app'.`然后没有变化，也没有commit。

![image-20240309235751205](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240309235751205.png)

我发现`gdb` 目标是用于启动 GNU 调试器 (GDB) 以调试生成的程序：在这个目标中，首先确保 `$(BINARY)` 已经构建，然后记录一个 "gdb" 的 Git 提交，最后启动 GDB 以调试程序。

`clean` 目标用于清除构建过程中生成的文件：其实相当于`rm -rf ./build`,其中`$(BUILD_DIR)`文件就是`build`，也就是把整个build文件夹删掉。

之后再次make，会执行编译操作，然后会提交一个compile的记录，然后在链接阶段输出一条提示信息，并实际执行链接操作。

之后再次make run由于make 过了，所以不会有compile的记录，只会有run的记录。

之后make gdb同理，只有gdb的记录。

**文件是如何编译的：**

`$(BINARY): $(OBJS)`这意味着make的时候首先会进行编译

而makefile当中有这样一段话：

```makefile
$(OBJ_DIR)/%.o: src/%.c
    @echo + CC $<
    @mkdir -p $(dir $@)
    @$(CC) $(CFLAGS) -c -o $@ $<
```

任何在 `$(OBJ_DIR)` 中的 `.o` 文件都是依赖于相应的在 `src/` 目录下的 `.c` 文件的。如图可以发现.c文件和.o文件是一一对应的，文件夹也是一一对应的。
![image-20240310103953078](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310103953078.png)

`@echo + CC $<`输出正在编译的源文件名,这就是为什么make 之后会有一堆+CC .c文件输出的原因

`mldir`创建了目标文件所在的目录，以防它不存在。

`$(CC)` 表示编译器（这里是 `gcc`），这句是实际的编译命令。

![](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310122949415.png)

**依赖文件**:

```shell
-include $(OBJS:.o=.d)
```

自动包含所有对象文件对应的依赖文件。这些依赖文件（`.d` 文件）通常由编译器生成，并包含了源文件与其包含的头文件之间的依赖关系。如果对象文件的任何依赖发生变化，Makefile 就能自动重新编译这些对象文件。`-include`: 如果某些 `.d` 文件不存在或生成错误，`-` 前缀防止了 make 退出。

![image-20240310123312247](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310123312247.png)

不难发现.d和.o文件是成对出现的。

**如何运行**

```shell
.PHONY: app run submit clean
app: $(BINARY)
ARGS ?= -l $(BUILD_DIR)/nemu-log.txt
NEMU_EXEC := $(BINARY) $(ARGS)
```

- `.PHONY: app run submit clean`: 声明这些目标不是实际文件，而是命令。即使有同名文件存在，它们也总是被执行。
- `ARGS ?= -l $(BUILD_DIR)/nemu-log.txt`: 这设置了一个默认的参数 `ARGS`，如果未被明确设置，则使用 `-l $(BUILD_DIR)/nemu-log.txt`。
- `NEMU_EXEC := $(BINARY) $(ARGS)`: 这定义了一个变量 `NEMU_EXEC`，它构建了一个命令行用于执行生成的程序。这里它包括了可执行文件的路径和额外的参数。

![image-20240310123736992](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310123736992.png)

到此为止，我理解了Makefile干了什么，简单总结就是:`make run`触发`make`，而`make`进行编译，去把src下的.c文件变成.o文件,并include.d文件，进行git commit之后链接。而run的时候git commit，然后执行nemu程序并且填入参数。

#### 2.1.1 NEMU 执行流程

正如之前makefile的分析，make run的时候会把src下的所有.c文件变成obj下的.o和.d,而程序的入口点是main.c文件。

首先我找到了main.c文件，它位于
```shell
/PAs/nemu/src/main.c
```



![image-20240310124508922](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310124508922.png)

不难发现其中只有两个函数，可以通过搜索快速定位第一个函数的，可以看到把main函数参数个数和具体参数都传入了进去。
![image-20240310125010657](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310125010657.png)

可以在
```shell
nemu\src\monitor
```

当中找到`init_monitor`函数，初始化模拟器函数
```c
int init_monitor(int argc, char *argv[]) {
  parse_args(argc, argv);//用来解析输入到main.c当中的参数
  init_log();
  reg_test();
#ifdef DIFF_TEST
  init_difftest();
#endif
  load_img();
  restart();
  init_regex();
  init_wp_pool();
  init_device();
  welcome();
  return is_batch_mode;
}

```

都比较重要，我细细分析：

**parse_args**:

首先是`parse_args`函数用来解析输入到main.c当中的参数
![image-20240310131429990](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310131429990.png)

- 使用 `getopt` 函数来解析参数。支持的选项包括 `-b`（设置批处理模式）、`-l`（指定日志文件），以及非选项参数（可能是镜像文件）。
- 如果指定 `-b`，则设置 `is_batch_mode` 为 `true`。
- 如果使用 `-l`，则设置 `log_file` 为提供的参数。
- 如果提供了非选项参数，且 `img_file` 未设置，则将其设置为该参数；否则记录一条警告信息。
- 如果遇到不认识的选项，程序会显示用法信息并退出。

这里我想起了之前的makefile里面有一句
```makefile
ARGS ?= -l $(BUILD_DIR)/nemu-log.txt
```

这里不恰好对应上`case -l`吗，也就是说之前的`ARGS ?= -l $(BUILD_DIR)/nemu-log.txt`指明了开启日志，并且日志记录到nemu-log.txt当中，于是我去找了`nemu/build/nemu-log.txt`果然发现有日志输出。

![image-20240310132243438](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310132243438.png)

一言以蔽之，**parse_args**的主要作用就是，记录`logfile=./build/nemu-log.txt`

**init_log**
在理解了parse_args之后，init_log也很好理解：

- 在 `DEBUG` 模式下工作。
- 如果没有指定 `log_file`，函数直接返回。
- 尝试以写模式打开 `log_file`，并将文件指针存储在 `log_fp` 中。
- 如果无法打开文件，程序断言失败并显示错误信息。

![image-20240310132848931](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310132848931.png)

一言以蔽之：**init_log**的作用就是打开main函数的参数当中的文件`./build/nemu-log.txt`，作为日志文件，因为要写入日志，所以要以写模式打开。

**reg_test**

接着就是寄存器的测试，要理解这一部分，我首先去看了`CPU_state`,但是没有完全看懂，于是我又去看了实验手册，发现提示：
![image-20240310133816157](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310133816157.png)

由于我去了解了一下union的用法和匿名union的用法，因为虽然我学过C++但是对于匿名union不是很了解。首先就是union的定义和使用几乎和struct一样，但是不同点在于：在 `union` 中，所有成员共享同一个内存空间。当修改 `union` 的一个成员时，这个操作实际上会影响到共享该内存空间的其他成员。所以在 `testunion` 函数中，对 `data` 的每一次赋值都在改变同一块内存的内容。这就是为什么最后只有一个属性可以被存储的原因。

![image-20240310153456985](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310153456985.png)





#### 2.1.2 代码: 实现正确的寄存器结构体

之前的代码

```c
typedef struct {
  struct {
    uint32_t _32;
    uint16_t _16;
    uint8_t _8[2];
  } gpr[8];
  rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;
  vaddr_t eip;
} CPU_state;
```

![image-20240308225259711](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240308225259711.png)
改进之后的代码

```c
typedef struct {
  union  {
    union {
      uint32_t _32;
      uint16_t _16;
      uint8_t _8[2];
    } gpr[8];
    struct
    {
      rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;
    };
  };
  vaddr_t eip;
} CPU_state;
```

![image-20240308225323852](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240308225323852.png)

#### 2.1.3 问题: 究竟要执行多久?




#### 2.1.4 问题: 谁来指示程序的结束?

### 2.2 基础设施: 简易调试器

#### 2.2.1 代码: 实现单步执行、打印寄存器、扫描内存

##### Bug1 主机与虚拟机间复制粘贴问题

我用了VMware17 PRO，下载了VMTools解决了这个问题。
本来从百度网盘下载的镜像是VM15 PRO，但是vm-tools安装不上【难点】，主机和虚拟机之间无法复制，所以改用了VMware17 PRO（密钥是网上公开的），助教说系统一致可以保证实验环境一致，而虚拟机不影响。下载好vmtools之后就可以复制粘贴了。

## 3 阶段二

### 3.1 词法分析

#### 3.1.1 代码: 实现算术表达式的词法分析

### 3.2 表达式求值

#### 3.2.1 代码: 实现算术表达式的递归求值

#### 3.2.2 代码: 实现带有负数的算术表达式的求值

#### 3.2.3 代码: 实现更复杂的表达式求值

##### Bug2 Linux 没有 pow() 函数?

#### 3.2.4 代码: 完善扫描内存的功能

##### Bug3 VMware Workstation 与 Device/Credential Guard 不兼容问题

## 4 阶段三

### 4.1 监视点

#### 4.1.1 代码: 实现监视点池的管理

#### 4.1.2 问题: static 的使用

#### 4.1.3 代码: 实现监视点

### 4.2 断点

#### 4.2.1 断点的工作原理

#### 4.2.2 问题: “一点也不能长?”

#### 4.2.3 问题: 随心所欲的断点

#### 4.2.4 问题: NEMU 的前世今生

### 4.3 i386 手册的学习

#### 4.3.1 问题: 通过目录定位关注的问题

#### 4.3.2 必答题

## 5 实验结论与感想




![image-20240223152400163](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240223152400163.png)

![image-20240223155616386](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240223155616386.png)

