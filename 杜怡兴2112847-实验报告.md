## PA1实验报告

### 杜怡兴2112847

[TOC]

## 1 概述

### 1.1 实验目的

### 1.2 实验内容

#### 1.2.1实验环境

- **虚拟机**：VMware17 PRO，本来从百度网盘下载的镜像是VM15 PRO，但是vm-tools安装不上【难点】，主机和虚拟机之间无法复制，所以改用了VMware17 PRO（密钥是网上公开的），助教说系统一致可以保证实验环境一致，而虚拟机不影响。

- **系统**：百度网盘里的Ubuntu系统，担心影响实验环境，没有升级。

- **vm-tools和共享文件夹**：
  下载vm-tools：

  ```shell
  sudo apt install open-vm-tools
  sudo apt install open-vm-tools-desktop
  ```

  设置好共享文件夹的位置，去/mnt/hgfs当中访问即可

- **开发工具**：VScode，由于共享文件夹，可以用Windows中的vscode修改文件，在Ubuntu当中生效，所以特别方便。
  ![image-20240306233116401](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240306233116401.png)

- **前置安装工作：**

  ```shell
  sudo apt-get install build-essential
  sudo apt-get install gdb
  sudo apt-get install git
  sudo apt install vim
  sudo apt-get install libreadline-dev
  sudo apt-get install libsdl2-dev
  sudo apt-get install qemu-system-x86
  ```

- **下载项目：** 

  ```shell
  git clone -b 2017 https://github.com/NJU-ProjectN/ics-pa.git ics2017
  ```

- **配置git信息:**
  用户名是我的学号和名字，邮箱是学生邮箱。

  ```shell
  git config user.name "2112847DuYixing"
  git config user.email "2112847@mail.nankai.edu.cn"
  git branch -m master
  ```

- **初始化：**
  这里我还了解到，bash init.sh还会涉及一些系统文件的设置，也就是说必须执行初始化之后的文件不能随便移动。
  
  ```bash
  bash init.sh
  ```
  
  ![image-20240306233235391](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240306233235391.png)

中间我还遇到了init.sh连接GitHub被拒绝的问题【难点】

```shell
fatal: unable to access 'https://github.com/NJU-ProjectN/nanos-lite.git/': Failed to connect to github.com port 443: Connection refused
```

解决方法是去csdn发现了下面的方法：

```shell
git config --global --unset http.proxy
git config --global --unset https.proxy
git config --global http.sslVerify "false"
```

- **查看gitlog**

  ```shell
  git log
  ```

  ![image-20240307001817261](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240307001817261.png)

  可以看到我在2024年3月6日等多日的记录。

  这里还遇到无法退出git log,CTRL+C也不行，后面发现应该是vim的退出方式，也就是:wq【插曲】。

- 尝试运行make run的时候还提示要去subproject里面，原来是要在nemu文件夹当中执行【插曲】

- 在nemu文件夹不可以执行git操作，因为需要在有.git的根目录【插曲】

- 创建新分支并切换到新分支

  ```shell
  git checkout -b pa1
  ```

  将新分支推送到远程仓库

  ```shell
  git push -u origin pa1
  ```

  















## 2 阶段一

### 2.1 简单计算机模型

#### 2.1.0 Makefile干了什么

要搞清楚make run干了什么，我先去看来make file。
![image-20240309231411656](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240309231411656.png)

​	**前五行定义了编译时的文件位置**。变量 `NAME` 的值为 `nemu`，然后 将当前目录下的 `include` 目录添加到变量 `INC_DIR` 中，然后如果变量 `BUILD_DIR` 未被之前定义，那么将其设置为当前目录下的 `build` 目录，类似地，设置 `OBJ_DIR` 为 `BUILD_DIR` 下的 `obj` 子目录。**`BINARY` 变量，代表最终生成的二进制文件的位置，也就是nemu。**

1. `include Makefile.git`: 包含另一个名为 `Makefile.git` 的 Makefile 文件。
2. `.DEFAULT_GOAL = app`: 设置默认目标为 `app``
3. ``CC = gcc`: 设置 C 编译器为 gcc。
4. `LD = gcc`: 设置链接器为 gcc。
5. `INCLUDES = $(addprefix -I, $(INC_DIR))`: 生成编译时包含的目录参数。
6. `CFLAGS += -O2 -MMD -Wall -Werror -ggdb $(INCLUDES)`: 设置 C 编译器标志

其中`Makefile.git`很有意思，`--author='tracer-ics2017 <tracer@njuics.org>'`: 设置提交的作者。

这就是为什么我可以在`git push -u origin `到GitHub（放心，是私有的）的时候看到我自己和另外一个作者的原因。

另外输出一些信息（包括传递给函数的消息、学生ID、用户名、系统信息、系统运行时间和一些随机数据），然后使用这些信息作为提交信息。
![image-20240309233248546](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240309233248546.png)

根据实验手册，需要修改这里的`STU_ID=2112847`。

我一直很好奇，为什么我一执行make run就会有一次commit，而且commit当中同时有run和commit，原来是因为：

在这个 `run` 目标中，发生了以下几个步骤：

1. `$(BINARY)`: 这是 `run` 目标的依赖项。它确保在运行 `run` 目标之前，必须先构建好 `$(BINARY)`（即程序的可执行文件）。在 `$(BINARY)` 目标中调用了 `git_commit` 函数并传递了 "compile" 作为参数,**所以同时会有run和commit。**
2. `$(call git_commit, "run")`: 这是 Makefile 中的函数调用语法。这里，它调用了 `Makefile.git` 中定义的 `git_commit` 函数，并传递了字符串 `"run"` 作为参数。这意味着**每次执行 `make run` 命令时，`git_commit` 函数都会被触发**，它会向 Git 仓库添加一个新的提交，提交信息中会包含 `"run"` 字符串以及其他在 `Makefile.git` 中定义的信息。
3. `$(NEMU_EXEC)`: 最后，执行由 `NEMU_EXEC` 变量定义的命令，即运行构建的程序。

![image-20240309233606273](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240309233606273.png)

我很好奇，如果单独执行 `make`，会执行什么。实验发现：

在 Makefile 中，`.DEFAULT_GOAL` 被设置为 `app`。所以，如果如果只运行 `make` 而不带任何参数，它将执行 `app` 目标：

```
.DEFAULT_GOAL = app
app: $(BINARY)
```

这会导致构建 `$(BINARY)`，如果 `$(BINARY)` 依赖的源代码文件有变化的话，它会重新编译。也就是我发现之前make过，之后在make只会输出`make: Nothing to be done for 'app'.`然后没有变化，也没有commit。

![image-20240309235751205](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240309235751205.png)

我发现`gdb` 目标是用于启动 GNU 调试器 (GDB) 以调试生成的程序：在这个目标中，首先确保 `$(BINARY)` 已经构建，然后记录一个 "gdb" 的 Git 提交，最后启动 GDB 以调试程序。

`clean` 目标用于清除构建过程中生成的文件：其实相当于`rm -rf ./build`,其中`$(BUILD_DIR)`文件就是`build`，也就是把整个build文件夹删掉。

之后再次make，会执行编译操作，然后会提交一个compile的记录，然后在链接阶段输出一条提示信息，并实际执行链接操作。

之后再次make run由于make 过了，所以不会有compile的记录，只会有run的记录。

之后make gdb同理，只有gdb的记录。

**文件是如何编译的：**

`$(BINARY): $(OBJS)`这意味着make的时候首先会进行编译

而makefile当中有这样一段话：

```makefile
$(OBJ_DIR)/%.o: src/%.c
    @echo + CC $<
    @mkdir -p $(dir $@)
    @$(CC) $(CFLAGS) -c -o $@ $<
```

任何在 `$(OBJ_DIR)` 中的 `.o` 文件都是依赖于相应的在 `src/` 目录下的 `.c` 文件的。如图可以发现.c文件和.o文件是一一对应的，文件夹也是一一对应的。
![image-20240310103953078](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310103953078.png)

`@echo + CC $<`输出正在编译的源文件名,这就是为什么make 之后会有一堆+CC .c文件输出的原因

`mldir`创建了目标文件所在的目录，以防它不存在。

`$(CC)` 表示编译器（这里是 `gcc`），这句是实际的编译命令。

![](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310122949415.png)

**依赖文件**:

```shell
-include $(OBJS:.o=.d)
```

自动包含所有对象文件对应的依赖文件。这些依赖文件（`.d` 文件）通常由编译器生成，并包含了源文件与其包含的头文件之间的依赖关系。如果对象文件的任何依赖发生变化，Makefile 就能自动重新编译这些对象文件。`-include`: 如果某些 `.d` 文件不存在或生成错误，`-` 前缀防止了 make 退出。

![image-20240310123312247](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310123312247.png)

不难发现.d和.o文件是成对出现的。

**如何运行**

```shell
.PHONY: app run submit clean
app: $(BINARY)
ARGS ?= -l $(BUILD_DIR)/nemu-log.txt
NEMU_EXEC := $(BINARY) $(ARGS)
```

- `.PHONY: app run submit clean`: 声明这些目标不是实际文件，而是命令。即使有同名文件存在，它们也总是被执行。
- `ARGS ?= -l $(BUILD_DIR)/nemu-log.txt`: 这设置了一个默认的参数 `ARGS`，如果未被明确设置，则使用 `-l $(BUILD_DIR)/nemu-log.txt`。
- `NEMU_EXEC := $(BINARY) $(ARGS)`: 这定义了一个变量 `NEMU_EXEC`，它构建了一个命令行用于执行生成的程序。这里它包括了可执行文件的路径和额外的参数。

![image-20240310123736992](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310123736992.png)

到此为止，我理解了Makefile干了什么，简单总结就是:`make run`触发`make`，而`make`进行编译，去把src下的.c文件变成.o文件,并include.d文件，进行git commit之后链接。而run的时候git commit，然后执行nemu程序并且填入参数。

#### 2.1.1 NEMU 执行流程

**答：简单说就是执行`main.c`当中的`main`函数，然后执行`init_monitor`和`ui_mainloop`，其中`init_monitor`进行各类初始化和测试操作，而`ui_mainloop`定义了一个用户界面的主循环，用于处理用户输入的命令。**
详细的分析如下：

##### main.c

正如之前makefile的分析，make run的时候会把src下的所有.c文件变成obj下的.o和.d,而程序的入口点是main.c文件。

首先我找到了main.c文件，它位于
```shell
/PAs/nemu/src/main.c
```



![image-20240310124508922](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310124508922.png)

不难发现其中只有两个函数，可以通过搜索快速定位第一个函数的，可以看到把main函数参数个数和具体参数都传入了进去。
![image-20240310125010657](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310125010657.png)

##### init_monitor

可以在

```shell
nemu\src\monitor
```

当中找到`init_monitor`函数，初始化模拟器函数
```c
int init_monitor(int argc, char *argv[]) {
  parse_args(argc, argv);//用来解析输入到main.c当中的参数
  init_log();
  reg_test();
#ifdef DIFF_TEST
  init_difftest();
#endif
  load_img();
  restart();
  init_regex();
  init_wp_pool();
  init_device();
  welcome();
  return is_batch_mode;
}

```

都比较重要，我细细分析：

##### parse_args:

首先是`parse_args`函数用来解析输入到main.c当中的参数
![image-20240310131429990](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310131429990.png)

- 使用 `getopt` 函数来解析参数。支持的选项包括 `-b`（设置批处理模式）、`-l`（指定日志文件），以及非选项参数（可能是镜像文件）。
- 如果指定 `-b`，则设置 `is_batch_mode` 为 `true`。
- 如果使用 `-l`，则设置 `log_file` 为提供的参数。
- 如果提供了非选项参数，且 `img_file` 未设置，则将其设置为该参数；否则记录一条警告信息。
- 如果遇到不认识的选项，程序会显示用法信息并退出。

这里我想起了之前的makefile里面有一句
```makefile
ARGS ?= -l $(BUILD_DIR)/nemu-log.txt
```

这里不恰好对应上`case -l`吗，也就是说之前的`ARGS ?= -l $(BUILD_DIR)/nemu-log.txt`指明了开启日志，并且日志记录到nemu-log.txt当中，于是我去找了`nemu/build/nemu-log.txt`果然发现有日志输出。

![image-20240310132243438](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310132243438.png)

一言以蔽之，**parse_args**的主要作用就是，记录`logfile=./build/nemu-log.txt`

##### init_log

在理解了parse_args之后，init_log也很好理解：

- 在 `DEBUG` 模式下工作。
- 如果没有指定 `log_file`，函数直接返回。
- 尝试以写模式打开 `log_file`，并将文件指针存储在 `log_fp` 中。
- 如果无法打开文件，程序断言失败并显示错误信息。

![image-20240310132848931](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310132848931.png)

一言以蔽之：**init_log**的作用就是打开main函数的参数当中的文件`./build/nemu-log.txt`，作为日志文件，因为要写入日志，所以要以写模式打开。

union

接着就是寄存器的测试，要理解这一部分，我首先去看了`CPU_state`,但是没有完全看懂，于是我又去看了实验手册，发现提示：
![image-20240310133816157](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310133816157.png)

由于我去了解了一下union的用法和匿名union的用法，因为虽然我学过C++但是对于匿名union不是很了解。
首先就是union的定义和使用几乎和struct一样，但是不同点在于：在 `union` 中，所有成员共享同一个内存空间，而这个空间的大小是由其最大成员决定的。当修改 `union` 的一个成员时，这个操作实际上会影响到共享该内存空间的其他成员。所以在 `testunion` 函数中，对 `data` 的每一次赋值都在改变同一块内存的内容。这就是为什么最后只有一个属性可以被存储的原因。

![image-20240310153456985](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310153456985.png)

正确的用法应该是：
![image-20240310153835102](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310153835102.png)

**nemu当中自己写测试**

因为后期免不了自己写一些测试用例，我定义了一个`nemu/src/mytest/function_test.c`用来测试，测试方法也很简单，在main文件当中写出要测试函数的定义，然后main函数当中直接使用即可。因为makefile可以把src下面的.c和main.c在一起编译。
![image-20240310154809820](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310154809820.png)

**匿名union**

由于实验手册当中提到了匿名union，但是我对于匿名union也不太熟悉，所以我去了解了一下:
匿名 `union` 是没有名字的 `union`。它通常用在结构体中，提供一种方式来访问同一内存位置的不同成员而不需要使用联合名。

![image-20240310155705094](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310155705094.png)


整个结构体的内存布局大致如下：

1. **`char type`**：这占用 1 字节。
2. **匿名 `union`**：这占用足够的空间来存储最大的成员，即 `char str[20]`。所以这部分是 20 字节。

整个结构体的大小至少是 21 字节（假设没有任何内存对齐）,并且intNum可以直接通过aunion.intNum来访问。如果后面给aunion.str赋值会导致原来的intNum被覆盖。这样我对于aunion已经有了充分的理解。

**enum**
由于我对于代码当中写的关于enum的部分也不太熟悉

```c
enum { R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI };
```

所以我自己测试了一下enum的效果。由于没有为这些枚举常量指定特定的值，所以它们将按照声明的顺序分别被赋予从 0 开始的整数值

![image-20240310162540478](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310162540478.png)

**typedef struct**

由于nemu的c语言确实有点晦涩难懂，尤其是关于struct的部分，所以我自己测试了一下struct的写法。
我假设要定义一个寄存器类，有三种方法：1.类似于类`class Reg{};`的写法，区别在于这种写法在定义对象的时候必须要用Struct+名字，不太方便。2.改进版写法，前面加一个typedef然后名字放到最后面，这样定义对象的时候和类完全一样。3.没有类只有对象的写法，就是不写名字，后面加一个对象名，缺点是类不见了不能重复使用。

![image-20240310164601087](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310164601087.png)

**assert**

为什么make run一开始会失败，就是因为assert，其实我之前知道一点assert，但是不太确定，经过查看资料：
nemu当中有大量的assert，`assert` 是 C 语言标准库中的一个宏，定义在头文件 `<assert.h>` 中，如果assert括号中表达式为真，程序继续正常运行；如果表达式为假（零），`assert` 会打印一条错误消息到标准错误输出，然后程序退出。

##### reg.h

要理解reg_test为什么出问题，还得理解reg.h，首先就是**enum**。
总共有三组，相当于定义了三组数。第一组值从`R_EAX=0`到`R_EDI=7`,对应的是8个通用寄存器,对应长度是32位。然后同一下标的位置是8个低16位寄存器，然后是前四个寄存器的低、高八位。
然后要理解**`gpr[8];`**是什么意思，实际上是"general purpose registers" 的缩写，意思是“通用寄存器”。

![image-20240310171225537](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310171225537.png)

**`reg_l`, `reg_w`, `reg_b` 宏**对于理解寄存器的数据结构是至关重要的。

- `reg_l(index)`: 获取 32 位 (`_32`) 寄存器视图。它使用 `check_reg_index` 确保索引有效。
- `reg_w(index)`: 获取 16 位 (`_16`) 寄存器视图。
- `reg_b(index)`: 获取 8 位 (`_8`) 寄存器视图。这个宏稍微复杂一些，因为 8 位视图需要考虑低 8 位 (`_8[0]`) 和高 8 位 (`_8[1]`) 的访问。该宏通过 `index & 0x3` 和 `index >> 2` 的操作来确定具体访问 `_8[0]` 还是 `_8[1]`。
- 在这里，`l`、`w` 和 `b` 是后缀，分别代表 "long word", "word" 和 "byte"，所以我突然理解了函数的意义。在 MIPS 架构中，一个 word 通常是 32 位（4 字节）、在 x86 架构中，word 的长度原本指的是 16 位（2 字节），和这里一致，但是后面又有扩展。在 RISC-V 架构中，word 的大小定义为 32 位（4 字节）。

![image-20240310172444542](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310172444542.png)

##### reg_test

首先就是CPU_state使用了struct的第三种定义方法。然后是在reg.h当中就定义了`extern regsb 、regsl 、regsw`，和enum的顺序和内容是一一对应。
`regsl` 可以理解为 "register long string" 或 "register long symbol"

![image-20240310175637789](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310175637789.png)

下面的代码不太好理解，但是我已经理解了，就是相当于遍历了i=0到i=7。然后让reg(0~7)=sample[0~7]=一个随机数。

然后就是reg_l发生了什么：

- **reg_l(6):**在i=6的时候，reg_l(6)相当于是获取第6号通用寄存器的32位视图。首先会判断6的范围的合理性，然后获取到cpu.gpr[6],然后它可以以三个形式存储在同一个地方(union的特性)，这三个形式当中要32位形式的，就是最终reg_l(6)的结果。同时对应着regsl[6]，也就是ESI。
  但是这一种方法比较难想，其实**reg_l[R_ESI]**是最简单的，也就是在`long word`寄存器当中找esi。

- **reg_w(6):**而reg_w(6)相当于是获取第6号通用寄存器的16位视图,或者说是获取regsw当中的第6个寄存器。首先会判断6的范围的合理性，然后获取到cpu.gpr[6],然后它可以以三个形式存储在同一个地方(union的特性)，这三个形式当中要16位形式的，就是最终reg_w(6)的结果。同时对应着regsw[6]，也就是SI。
  但是这一种方法比较难想，其实**reg_w[R_SI]**是最简单的，也就是在`word`寄存器当中找si。
- **reg_b(6)**:而reg_b(6)是获取regsb当中的第6个寄存器。首先会判断6的范围的合理性，然后获取到cpu.gpr[2],然后它可以以三个形式存储在同一个地方(union的特性)，这三个形式当中要8位形式的,由于(6>>2==1)所以是要高八位形式的，就是最终reg_b(6)的结果。同时对应着regsb[6]，也就是DH。
  但是这一种方法比较难想，其实**reg_b[R_DH]**是最简单的，也就是在`byte`寄存器当中找DH。

```c
  int i;
  for (i = R_EAX; i <= R_EDI; i ++) {
    sample[i] = rand();
    reg_l(i) = sample[i];
    assert(reg_w(i) == (sample[i] & 0xffff));
  }
```

上面这一段代码本来assert会失败，但是通过修改寄存器结构体可以解决，详情见`正确实现寄存器结构体`部分。

##### init_difftest

这一段代码用处不多，简单说就是：创建一个子进程来运行 QEMU 模拟器，同时在父进程中使用 GDB 进行调试，旨在设置一个差分测试环境。子进程负责启动并运行 QEMU，包括处理父进程死亡信号和检查父进程是否仍存在，而父进程则负责与 QEMU 的 GDB 服务器连接，发送主引导记录（MBR）代码到 QEMU，并通过 GDB 设置寄存器和执行指令。这样的设置允许在模拟环境中运行代码，并通过 GDB 调试器进行监视和分析，以测试和验证系统的行为。

##### load_img

![image-20240311143635495](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240311143635495.png)

`load_img` 函数是用来加载映像文件的主要函数。

1. **如果未指定映像文件**：
   - 调用 `load_default_img` 来加载内嵌的默认映像。这个内嵌映像是一个硬编码(用机器码写的)的、用于测试目的的小型程序。
2. **如果指定了映像文件**：
   - 打开并读取该文件，然后将文件内容加载到模拟器的内存中。
   - 使用 `fopen` 打开文件，`fseek` 和 `ftell` 来确定文件大小，`fread` 读取文件内容。
   - `assert` 确保读取操作正确完成。
3. **在差分测试模式下**（如果定义了 `DIFF_TEST`）：
   - 将加载的映像内容复制到 QEMU 模拟器的内存中，以便进行差分测试

##### restart

很简单：设置 CPU 的指令指针 (`eip`) 到起始地址 `ENTRY_START`。执行将从该地址开始。在差分测试模式下，需要进行额外的初始化
##### init_regex

使用 `regcomp` 函数编译一系列正则表达式，如果编译失败，使用 `regerror` 获取错误信息。
##### init_wp_pool

![image-20240311144812094](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240311144812094.png)

- 初始化一个 `wp_pool` 数组，该数组包含一定数量 (`NR_WP`) 的监视点。
- 设置每个监视点的编号，**并将它们链接成一个链表。**
- 初始化头指针 `head` 和一个指向空闲监视点链表的指针 `free_`。

##### init_device

不是很重要：初始化模拟器或嵌入式系统中的各种设备，并处理定时器和输入事件。

##### welcome

打印欢迎信息，并显示构建时间.这里Log是一个宏，效果就是在屏幕打印。

![image-20240311142946692](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240311142946692.png)

##### ui_mainloop

![image-20240311154425677](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240311154425677.png)

如果 `is_batch_mode` 为真，函数将执行 `cmd_c(NULL)`,也就是`cput_exec(-1)`执行程序。其中，通过makefile和`parse_args`可以发现，如果编译的时候main函数里传入参数是`b`,就会开启`batch_mode`。

如果不是批处理模式，函数进入一个无限循环，等待和处理用户输入的命令。在循环内部，首先获取用户输入的字符串。接着从输入字符串中解析出第一个单词作为命令。剩下的字符串被当作命令的参数，这可能需要进一步解析。循环遍历命令表 `cmd_table` 来找到匹配的命令，并执行相应的处理函数。
![image-20240311154831956](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240311154831956.png)

#### 2.1.2 代码: 实现正确的寄存器结构体

##### 第一个union

之前的代码会有一个报错
![image-20240308225259711](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240308225259711.png)

这是由于main函数执行init_monitor,而init_monitor当中又有一个reg_test，而reg_test当中有一个for循环:

![image-20240310181402536](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310181402536.png)


这是之前的寄存器结构:

```c
typedef struct {
  struct {
    uint32_t _32;
    uint16_t _16;
    uint8_t _8[2];
  } gpr[8];
  rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;
  vaddr_t eip;
} CPU_state;
```

这是不正确的，原因是：

每个 `gpr` 数组元素是一个 **`struct`**，其中 **`_32`、`_16` 和 `_8` 是独立的字段。**这意味着每个字段占据自己的内存区域，不与其他字段共享内存。因此，写入 `_32` 字段不会影响 `_16` 字段的内容。

所以，当执行 `reg_l(i) = sample[i];` 时，只是修改了 `_32` 字段的内容，而 `_16` 字段保持不变。因此，`assert(reg_w(i) == (sample[i] & 0xffff));` **断言会失败，因为 `reg_w(i)`（即 `_16` 字段）的值并没有被更改，而sample[i]被赋值了，不相等，所以失败**

改进之后的代码：

```c
typedef struct {
  union {
    uint32_t _32;
    uint16_t _16;
    uint8_t _8[2];
  } gpr[8];
//还没有改完
} CPU_state;
```

之前的报错会消失，原因是：

每个 `gpr` 数组元素是一个 **`union`，其中 `_32`、`_16` 和 `_8` 共享相同的内存区域**。这意味着对其中任何一个字段的修改都会反映在其他字段上。

因此，当执行 `reg_l(i) = sample[i];` 时，实际上修改了整个 32 位内存区域的内容，这也隐式地改变了 `_16` 字段的内容。**因为 `_16` 字段实际上是 `_32` 字段的低 16 位，所以 `assert(reg_w(i) == (sample[i] & 0xffff));` 断言会成功。**
![image-20240310183029132](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310183029132.png)

事实上，对于`reg_l`和`reg_w`发生了什么，在NEMU的执行流程当中有非常详细的论述。

##### 小端序

但是事情并没有这么简单: **为什么union当中\_16是\_32的低16位，而\_8[0]是\_16低8位，\_8[1]是\_16的高8位**?

**这是和x86系统是小端序(众所周知)有关的,**为了验证这一点,我写了一个测试.
![image-20240310185942364](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310185942364.png)

测试1:

- 如果系统是小端序，`int` 变量的低位字节将存储在低地址处。因此，`p[0]` 将是 `0x78`，`p[1]` 将是 `0x56`，依此类推，最后输出的将是 `78 56 34 12`。
- 如果系统是大端序，高位字节将存储在低地址处，输出将会是 `12 34 56 78`。

测试2:

- 在小端序系统中，`0x01` 是存储在最低位地址的字节，所以 `c.b`（访问最低位字节）将是 `1`，因此输出“little endian”。
- 在大端序系统中，`0x01` 存储在最高位地址，而最低位地址的字节将是 `0x00`，所以 `c.b` 将不等于 `1`，因此输出“big endian”。

上述实验不仅仅证明了当前系统确实是小端序,而且还说明了正因为小端序,所以寄存器union当中\_16是\_32的低16位，而\_8[0]是\_16低8位，\_8[1]是\_16的高8位的效果.其实这里还有一个点,就是union共享内存的时候会始于同一低地址.

![image-20240310190821782](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310190821782.png)

##### 第二个union

然而问题只解决了一半，之前的报错解决了，出现了新的报错:

![image-20240310182706200](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310182706200.png)

先看这段检查

```c
  assert(reg_b(R_AL) == (sample[R_EAX] & 0xff));
```

首先这一段检查已经全部通过，这是因为通过union共享空间，sample[0]和gpr[0].共享同一个空间,并且由于之前的图,可以看出`_32,_16,_8[0],_8[1]`可以正确的获取到各类寄存器,而通过.
没有通过的是这一段代码:

```c
  assert(sample[R_EAX] == cpu.eax);
```

这是由于reg.h当中有:
```c
typedef struct {
  union {
    uint32_t _32;
    uint16_t _16;
    uint8_t _8[2];
  } gpr[8];
  rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;
} CPU_state;
```

这里的 `gpr` 数组和 `eax`, `ecx`, `edx`, `ebx`, `esp`, `ebp`, `esi`, `edi` 是独立的内存块。当通过 `reg_l(index)` 宏（即 `cpu.gpr[index]._32`）给寄存器赋值时，实际上只修改了 `gpr` 数组中相应元素的 `_32` 字段。这并不影响 `eax`, `ecx`, `edx`, `ebx`, `esp`, `ebp`, `esi`, `edi` 这些独立的寄存器变量。因此，`assert(sample[R_EAX] == cpu.eax);` 失败，因为 `cpu.eax` 并没有被 `sample[R_EAX]` 的值更新。

正确的定义:
```c
typedef struct {
  union {
    union {
      uint32_t _32;
      uint16_t _16;
      uint8_t _8[2];
    } gpr[8];
    struct { rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi; };
  };
} CPU_state;
```

`gpr` 数组和 `eax`, `ecx`, `edx`, `ebx`, `esp`, `ebp`, `esi`, `edi` 寄存器共享相同的内存空间，因为它们都位于同一个外层 `union` 里。在这种情况下，修改 `gpr[index]._32` 同时也会影响到对应的具名寄存器（例如 `eax`）。因此，当执行 `reg_l(i) = sample[i];` 时，`cpu.eax`（如果 `i` 是 `R_EAX`）也会被相应地更新。这就是为什么 `assert(sample[R_EAX] == cpu.eax);` 成功的原因。
![image-20240311141515384](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240311141515384.png)


![image-20240308225323852](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240308225323852.png)

到此为止,问题全部解决,make run输出Welcome.

#### 2.1.3 问题: 究竟要执行多久?

答：几乎一直执行下去。

![image-20240311150821239](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240311150821239.png)

当用户在控制台输入 "c" 命令后，首先被 `cmd_table` 中对应的条目识别，该条目指向 `cmd_c` 函数，`cmd_c` 函数被调用。它接着调用 `cpu_exec(-1)`，`uint64_t` 是一个无符号 64 位整数类型。当尝试将 `-1` 赋值给一个无符号整数时，由于 `-1` 在二进制表示中是全 1，因此它会转换为无符号类型的最大值。对于 `uint64_t`，这个值是 `0xFFFFFFFFFFFFFFFF`。
在 `for(; n > 0; n--)` 循环中，由于 `n` 被初始化为 `0xFFFFFFFFFFFFFFFF`,所以循环将执行非常多次，可以理解为几乎一直执行下去。

因此，对于手册上的问题：
**`在 cmd_c()函数中,调用 cpu_exec()的时候传入了参数-1,你知道这是什么意思吗?`**

我的回答是：`uint64_t n=-1`，意味着n=`0xFFFFFFFFFFFFFFFF`,目的是让程序一直执行下去，for循环在人能够感受的时间内不会停下来【除非遇到断点、程序正常结束或发生异常，根据实验手册，`nemu: HIT GOOD TRAP at eip = 0x00100026`说明程序正常结束】。

#### 2.1.4 问题: 谁来指示程序的结束?

答：**atexit()**
**`atexit()`** 用于注册终止函数(即main执行结束后调用的函数)，其原型为：` int atexit(void (*<[function]>)(void); `

当程序正常终止时，由 function指向的函数将自动被调用，且不带任何参数。如果函数成功注册，将返回零值。如果失败，则返回非零值。

这一点可以在atexit.c看到
![image-20240311160607689](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240311160607689.png)


### 2.2 基础设施: 简易调试器

#### 2.2.1 代码: 实现单步执行、打印寄存器、扫描内存

#### 思路

根据实验手册和之前的分析，一条指令要想被识别，需要加入`cmd_table`，包含三个部分，触发的关键词,描述，以及要触发的函数。如图可以实现输入si，打印`si指令被触发`。

![image-20240312093810494](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240312093810494.png)

##### si指令

代码实现如图。

如果si之后没有参数，执行一步指令，如果有参数，使用了 `sscanf` 来尝试解析用户输入的参数。如果成功解析并且n是正整数，就执行n步指令，n不是整数或者不是正整数，则报错(不同情况用了不同颜色进行标注)。对于中间有多余空格的情况`si   1`也可以正确解析。
所示代码执行的效果符合预期。(执行了正确数量的正确指令，与之前default_img内核对应)。

![image-20240312101428158](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240312101428158.png)





##### Bug1 主机与虚拟机间复制粘贴问题

我用了VMware17 PRO，下载了VMTools解决了这个问题。
本来从百度网盘下载的镜像是VM15 PRO，但是vm-tools安装不上【难点】，主机和虚拟机之间无法复制，所以改用了VMware17 PRO（密钥是网上公开的），助教说系统一致可以保证实验环境一致，而虚拟机不影响。下载好vmtools之后就可以复制粘贴了。
![image-20240310172119758](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310172119758.png)

## 3 阶段二

### 3.1 词法分析

#### 3.1.1 代码: 实现算术表达式的词法分析



### 3.2 表达式求值

#### 3.2.1 代码: 实现算术表达式的递归求值



#### 3.2.2 代码: 实现带有负数的算术表达式的求值



#### 3.2.3 代码: 实现更复杂的表达式求值



##### Bug2 Linux 没有 pow() 函数?



#### 3.2.4 代码: 完善扫描内存的功能



##### Bug3 VMware Workstation 与 Device/Credential Guard 不兼容问题

## 4 阶段三

### 4.1 监视点

#### 4.1.1 代码: 实现监视点池的管理

#### 4.1.2 问题: static 的使用

#### 4.1.3 代码: 实现监视点

### 4.2 断点

#### 4.2.1 断点的工作原理

#### 4.2.2 问题: “一点也不能长?”

#### 4.2.3 问题: 随心所欲的断点

#### 4.2.4 问题: NEMU 的前世今生

### 4.3 i386 手册的学习

#### 4.3.1 问题: 通过目录定位关注的问题

通过i386手册的目录、通过wps的查找功能我可以轻松定位关注的问题。
在看reg.h的时候，我希望知道三组enum对应的寄存器的结构，然后就找到了图示，非常清晰。

![image-20240310170931497](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20240310170931497.png)



#### 4.3.2 必答题

## 5 实验结论与感想







